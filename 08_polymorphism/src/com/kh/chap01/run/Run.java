package com.kh.chap01.run;

import com.kh.chap01.model.vo.Child1;
import com.kh.chap01.model.vo.Child2;
import com.kh.chap01.model.vo.Parent;

public class Run {
	/*
	 * 상속 
	 * 
	 * 필드 / 메소드 => 별로 안중요함
	 * 
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 * 											타 		입     =     (  자  료  형  ) 을 물려주는 구나 ! 8번 파트는 이것만 잘 기억하고 가시면 돼요.
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 * ☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆
	 */
	public static void main(String[] args) {
		
		// 1. 부모 타입 자료형으로 부모 타입 객체를 다룸
		Parent p1 = new Parent();
		p1.printParent(); 
		// p1.printChild1(); 안되는 이유 =>> 자바에서는 자식이 부모를 선택합니다. 부모 입장에서는 누가 자식인지 모르고 자식이 뭘 가지고 있는지도 모릅니다.
		// p1 변수로는 Parent에만 접근이 가능하다.
		
		// 2. 자식 타입 자료형으로 자식 타입 객체를 다룸
		Child1 c1 = new Child1();
		c1.printChild1(); // 내껀 내꺼~~~
		c1.printParent(); // 부모꺼도 내꺼~~~
		// c1 변수로는 Child1, Parent 둘 다 접근 가능
		
		// =   <-- 얘를 기준으로 양변의 자료형이 같아야 한다.
		// 3. 부모 타입 자료형으로 자식 타입 객체를 다룸
		Parent p2 = /*(Parent)*/ new Child1();  // <-- 우리 눈에 보이지 않지만 자료형 변환이 일어난 것이다. 상속 구조이기 때문에.
		// ☆★☆★☆★☆★ 상속에서 가장 중요한 것 => 자료형을 물려받는다. ☆★☆★☆★☆★
		p2.printParent();
		// p2.printChild1();
		// p2로는 parent 타입만 접근할 수 있구나~! 왜? 내가 자료형을 parent 타입으로 쓸 거야! 라고 해놨으니까.
		
		// 양쪽의 자료형이 다름에도 불구하고 에러가 발생하지 않는 이유는
		// 부모클래스인 Parent가 자식클래스인 Child1에게 타입을 물려주어서
		// 클래스 형변환이 일어났기 때문
		
		/*
		 * 클래스 형 변환
		 * 
		 * "상속 구조"일 경우에만 가능
		 * 
		 * 1. Up Casting
		 * : 자식타입 => 부모타입 으로 형변환
		 * 생략이 가능함
		 * 
		 * 2. Down Casting
		 * : 부모타입 => 자식타입 으로 형변환
		 * 생략이 불가능함
		 */
		((Child1)p2).printChild1(); // 부모를 자식으로 형변환 하는 방법
		
		// Child1 타입의 객체 두 개
		// Child2 타입의 객체 두 개
		// 총 네 개의 객체를 다뤄볼 것
		
		/*
		Child1 child1 = new Child1();
		Child1 child2 = new Child1();
		Child2 child3 = new Child2();
		Child2 child4 = new Child2();
		
		child1.printChild1();
		child2.printChild1();
		child3.printChild2();
		child4.printChild2();
		*/
		
		// 배열을 사용해보자
		// 배열 == 한 종류의 자료형인 값들을 묶어서 관리할 수 있음
		/* 객체 배열로는 여기까지 할 수 있다.
		Child1[] arr1 = new Child1[2];
		Child2[] arr2 = new Child2[2];
		arr1[0] = new Child1();
		arr1[1] = new Child1();
		arr2[0] = new Child2();
		arr2[0] = new Child2();
		
		arr1[0].printChild1();
		arr1[1].printChild1();
		arr2[0].printChild2();
		arr2[0].printChild2();
		*/
		
		System.out.println("\n\n\n다형성을 적용해보자");
		Parent[] arr = new Parent[4];
		arr[0] = (Parent)new Child1(); // Child1 은 Parent 타입의 자료형을 상속받고 있기 때문에 들어갈 수 있음.
		arr[1] = (Parent)new Child2();
		arr[2] = new Child2();
		arr[3] = new Child1();
		
		// arr[0].printChild1(); <-- 부모 타입이 자식 타입을 사용할 수 없네요.
		for(int i = 0; i < arr.length; i++) {
			arr[i].printParent();
		}
		
		System.out.println("\n\n\n\n");
		for(int i = 0; i < arr.length; i++) {
			
			/*
			if(i == 0 || i == 3) {
				((Child1)arr[i]).printChild1();
			} else {
				((Child2)arr[i]).printChild2();
			}
			*/
			/* 이건 알려드리고 싶어서 쓴 것이고 중요하지 않습니다.
			if(arr[i] instanceof Child1) {
				// instanceof => 반환값이 true / false
				// 현재 참조변수가 실질적으로 어떤 클래스타입을 참조하고 있는지 확인할 때 사용
				((Child1)arr[i]).printChild1();
			} else {
				((Child2)arr[i]).printChild2();
			}
			*/
			
			arr[i].print();
			// 원래 같으면 부모클래스 머시기 X 4 출력이 일어나야하는데
			// 실질적으로 우리가 참조하고 있는 친구들은 Child 자식 타입 객체이다. 주소를 찾아가보니까 부모가 있는 게 아니라 자식 타입 객체들이 있다.
			// 같은 메소드가 있다면 자식 메소드가 우선순위 호출된다.
			// 위에서부터 변수로 다뤘을때, 배열로 다뤘을때, 다형성으로 다뤘을때 방법이 어떤 차이가 있는지 살펴보세요.
			
			/*
			 * 우리가 오버로딩을 앞에서 배웠을 때 정적바인딩을 배웠다.
			 * 오버로딩과 오버라이딩의 차이는?
			 * 동적바인딩 : 프로그램 "실행 전" 컴파일 시점에 정적바인딩을 수행하는데(자료형의 메소드를 가리킴)
			 * 			실질적으로 참조하고 있는 객체가 해당 메소드를 오버라이딩 했다면
			 * 			프로그램 "실행 시점" 동적으로 자식클래스의 오버라이딩된 메소드를 실행한다.
			 *				   (Runtime) 
			 *
			 * 우리가 이것을 다형성이라는 개념을 적용해서
			 * 다형성 : 부모클래스 자료형으로 여러 자식클래스를 다루는 기술					
			 */
		}
		
	}

}
