package com.kh.chap05.model.vo;
/*
 * Interface
 * 
 * [ 표현법 ]
 * 
 * 접근제한자 interface 인터페이스식별자 {
 * 
 * 			일반적으로 클래스는
 * 			//필드 //생성자 //메소드 로 구성되어 있는데
 * 			인터페이스는 생성자를 가질 수 없다. => 객체 생성 불가능
 * 		즉, //필드 //메소드
 * } 
 *
 * 구체 클래스 
 * 추상 클래스
 * 인터페이스
 * ↑ 위에 세 가지는 완전히 다른 겁니다.
 * 우리가 지금까지 만들어온 것은 '구체 클래스'입니다.
 * abstract 가 붙은 것은 '미완성/추상 클래스'입니다.
 * '인터페이스'는 추상화를 코드상으로 옮겨놓은 느낌입니다.
 * 
 * 
 * - 추상클래스보다 더욱 강한 규칙성, 강제성을 가짐
 * 
 * - 인터페이스의 필드는 상수 필드
 * 
 * - 인터페이스의 메소드 키워드를 붙이지 않는 이상 추상메소드
 * 
 * - 인터페이스는 다중 구현을 허용합니다.
 * != 상속은 단일 구현
 * 
 * - "무조건 구현해야하는 기능이 있을 경우 인터페이스를 사용해서
 * 	  사용법만 만들어주고 구현하는 쪽에서 실체화하게 만듬" ==> 오버라이딩
 * 
 * 
 * 1. 추상클래스와 인터페이스의 공통점
 * 
 * - 객체 생성은 불가능하지만, 부모자료형의 참조타입으로는 사용이 가능함(다형성 적용할 수 있음)
 * - 추상메소드를 가지고 있을 경우, 상속(구현)받는 클래스에서 추상메소드를 오버라이딩 하도록 강제함
 * 
 * 2. 차이점
 * 
 * - 추상클래스 : 멤버로 일반필드, 일반메소드를 가질 수 있음
 * 				추상메소드는 있어도 그만 없어도 그만
 * 
 * - 인터페이스 : 상수 필드||특정한 경우를 제외하면 모든 메소드를 추상메소드로 정의 해야함				
 * 
 * 둘 다 다형성을 적용하여 외부에서 보여지는 타입의 용도로 사용하지만
 * But 두 친구의 목적이 다릅니다.
 * -> 추상클래스는 자식클래스가 상속을 받아서 필드 / 메소드를 재사용하고 클래스를 확장하는 용도
 * -> 인터페이스는 기능의 구현을 강제하기 위한 용도
 */
public interface MusicI {
	/*
	 * 인터페이스로는 객체 생성이 불가능하기 때문에 생성자를 기술할 수 없음
	 * public MusicI() {}
	 */
	// 필드부 작성해볼까요?
	/*public static final*/ int NUM = 1; // <= 스태틱 파이널은 상수필드라고 부릅니다. 
	// 상수필드니까 대문자로 이름 써주고 초기화까지 해줘야함.
	// 인터페이스의 모든 필드들은 암묵적으로 public static final
	
	/*
	 * public void hi() {
	 */
//}	
	/*public abstract*/ void play();
	// 인터페이스의 메소드들은 기본적으로 추상메소드
	default void stop() {    
		System.out.println("음악을 멈춥니다.");
	} // 인터페이스를 구현하는 모든 클래스가 동일하게 수행해야하는 메소드에는 default 키워드를 붙인다.
	// 우리가 앞에서 배웠던 디폴트랑 여기 디폴트는 완전히 다릅니다.
	
}
